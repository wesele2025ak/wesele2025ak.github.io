<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Prześlij zdjęcie — live</title>
<style>
  :root{color-scheme:dark}
  body{font-family:system-ui, sans-serif;margin:0;padding:16px;background:#0b0c10;color:#e8e8e8}
  .card{max-width:900px;margin:0 auto;background:#121317;border:1px solid #23242a;border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,.35)}
  h1{font-size:1.15rem;margin:0 0 8px}
  .muted{color:#a7a7a7;font-size:.95rem}
  .status{margin-top:10px;padding:10px;border-radius:8px;background:#0e1116;border:1px solid #1f2530;white-space:pre-wrap;min-height:3em}
  .ok{border-color:#2a5}.err{border-color:#d55}
  .metaRow{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-top:10px}
  .controlsBar{display:flex;gap:8px;align-items:center}
  button{font:inherit;background:#1f88ff;color:#fff;border:none;padding:8px 10px;border-radius:8px;cursor:pointer}
  button[disabled]{opacity:.6;cursor:not-allowed}
  .videoWrap{margin-top:12px;position:relative;border-radius:12px;overflow:hidden;background:#000;min-height:320px;display:none}
  video{width:100%;height:100%;display:block;background:#000;object-fit:cover}
  .previewImg{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;display:none;z-index:5}
  .overlays{position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none}
  .control{position:absolute;pointer-events:auto;background:rgba(20,22,26,.55);border:1px solid rgba(255,255,255,.06);backdrop-filter:blur(6px);display:flex;align-items:center;justify-content:center;border-radius:999px;padding:8px;cursor:pointer;color:#fff;z-index:7}
  .control svg{width:20px;height:20px;display:block}
  .control.small{width:44px;height:44px}
  .control.big{width:72px;height:72px;background:linear-gradient(180deg,#2a86ff,#1a6fe0,.55);box-shadow:0 6px 18px rgba(25,110,220,.25)}
  .control.topRight{top:12px;right:12px}
  .control.topLeft{top:12px;left:12px}
  .control.topLeft.offset{left:64px}
  .control.bottomCenter{left:50%;transform:translateX(-50%);bottom:18px}
  .control.bottomLeft{left:16px;bottom:16px;top:auto;right:auto;transform:none;z-index:8}
  .control.bottomRight{right:16px;bottom:16px;top:auto;left:auto;transform:none;z-index:8}
  .control.topCenter{left:50%;transform:translateX(-50%);top:18px}
  .control.leftCenter{top:50%;left:18px;transform:translateY(-50%)}
  .control.rightCenter{top:50%;right:18px;transform:translateY(-50%)}
  .control.hidden{display:none}
  .control.active{background:linear-gradient(180deg,#ffd166,#ffb347);color:#111;border-color:rgba(255,255,255,0.08)}
  .hint{margin-top:8px;font-size:.9rem;color:#cfcfcf}
  .inApp{margin-top:8px;padding:8px;background:#16181b;border:1px solid #2a2d33;border-radius:8px}
  input[type=file]{position:absolute;left:-9999px}
  .flash{position:fixed;left:0;top:0;right:0;bottom:0;pointer-events:none;background:rgba(255,255,255,0);opacity:0;transition:opacity .12s ease;mix-blend-mode:screen;z-index:9999}
  .flash.do{opacity:0.92;background:white}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;padding:10px 16px;border-radius:10px;background:rgba(20,20,20,0.92);color:#fff;box-shadow:0 6px 18px rgba(0,0,0,.5);font-weight:700;z-index:9999;display:none}
  .toast.show{display:block;animation:toast-in .22s ease}
  @keyframes toast-in{from{transform:translateX(-50%) translateY(8px);opacity:0}to{transform:translateX(-50%) translateY(0);opacity:1}}
  .progressOverlay{position:absolute;top:18px;left:50%;transform:translateX(-50%);width:72%;max-width:720px;z-index:6;pointer-events:none;display:flex;flex-direction:column;gap:10px;align-items:stretch;opacity:0;transition:opacity .15s linear}
  .progressOverlay.visible{opacity:1}
  .progressWrap{height:16px;background:rgba(20,21,24,.88);border-radius:999px;overflow:hidden;border:1px solid rgba(255,255,255,.06);flex:1;min-width:140px}
  .progressBar{height:100%;width:0%;background:#1f88ff;transition:width .12s linear}
  .progressRowInner{display:flex;align-items:center;gap:12px;padding:6px}
  .progressText{font-size:.95rem;color:#cfcfcf;min-width:48px;text-align:right}
  .progressMessage{font-size:1.05rem;color:#bff7c6;text-align:center;font-weight:700}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  .hidden{display:none !important}
  #captureBtn{
    background:
      linear-gradient(180deg, rgba(31,136,255,0.22), rgba(26,110,224,0.18)),
      rgba(20,22,26,0.28);
    backdrop-filter: blur(8px) saturate(120%);
    -webkit-backdrop-filter: blur(8px) saturate(120%);
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 8px 22px rgba(26,110,220,0.20);
    width: 80px;
    height: 80px;
    padding: 0;
  }
  #captureBtn svg {
    width: 40px;
    height: 40px;
    display: block;
    margin: 0;
  }
</style>
</head>
<body>
  <div class="card">
    <h1>Dodaj zdjęcie — podgląd live</h1>
    <div class="muted" id="eventInfo">Sprawdzam token...</div>
    <div class="status" id="statusBox">Gotowy.</div>
    <div style="height:10px"></div>
    <div class="metaRow">
      <div class="controlsBar" id="topControls">
        <button id="openBtn">Uruchom aparat</button>
        <button id="retryPermBtn">Sprawdź uprawnienia</button>
        <button id="openInBrowserBtn" style="display:none">Otwórz w przeglądarce</button>
        <input id="file" type="file" accept="image/*" capture="environment" />
      </div>
    </div>
    <div class="videoWrap" id="videoWrap" aria-hidden="true">
      <video id="camVid" autoplay playsinline muted></video>
      <img id="previewImg" class="previewImg" alt="Podgląd zrobionego zdjęcia" />
      <div class="overlays" id="overlays">
        <div class="progressOverlay" id="progressOverlay" aria-hidden="true">
          <div class="progressRowInner">
            <div class="progressWrap"><div class="progressBar" id="progressBar"></div></div>
            <div class="progressText" id="progressText">…</div>
          </div>
          <div class="progressMessage" id="progressMessage" aria-live="polite"></div>
        </div>
        <button class="control topRight small" id="fsBtn" aria-label="Pełny ekran" title="Pełny ekran">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M9 3H5a2 2 0 0 0-2 2v4"/><path d="M15 21h4a2 2 0 0 0 2-2v-4"/><path d="M21 9V5a2 2 0 0 0-2-2h-4"/><path d="M3 15v4a2 2 0 0 0 2 2h4"/></svg>
        </button>
        <button class="control topLeft small hidden" id="stopBtn" aria-label="Wyłącz aparat" title="Wyłącz aparat">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="7" width="18" height="12" rx="2" ry="2"/><path d="M9 7l1.5-2h3L15 7"/><circle cx="12" cy="13" r="3"/><path d="M4 4L20 20"/></svg>
        </button>
        <button class="control bottomCenter big" id="captureBtn" aria-label="Zrób zdjęcie" title="Zrób zdjęcie">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="7" width="18" height="12" rx="2" ry="2"/><path d="M9 7l1.5-2h3L15 7"/><circle cx="12" cy="13" r="3"/></svg>
        </button>
        <button class="control bottomLeft small hidden" id="torchBtn" aria-label="Włącz lampę" title="Włącz lampę">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8a4 4 0 0 0 0 8" fill="currentColor"/><circle cx="12" cy="12" r="4"/><line x1="12" y1="2" x2="12" y2="4"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="2" y1="12" x2="4" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="12" y1="20" x2="12" y2="22"/> </svg>
        </button>
        <button class="control bottomRight small" id="switchBtn" aria-label="Przełącz aparat" title="Przełącz aparat">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M4 12a8 8 0 0 1 13.5-5.5"/><polyline points="16 3 17.5 6.5 14 6.5"/><path d="M20 12a8 8 0 0 1-13.5 5.5"/><polyline points="8 21 6.5 17.5 10 17.5"/></svg>
        </button>
      </div>
    </div>
    <div class="hint" id="hintBox">Naciśnij "Uruchom aparat", następnie środkowy przycisk, aby zrobić zdjęcie. Możesz przełączać aparaty i wejść w pełny ekran.</div>
    <div class="inApp" id="inAppBox" style="display:none"></div>
  </div>
  <div class="flash" id="flash"></div>
  <div class="toast" id="toast">Wysłano</div>
<script>
(function(){
  "use strict";

  const WORKER_URL = 'https://wesele-worker.wesele2025ak.workers.dev/upload';
  const qs = new URLSearchParams(location.search);
  const eventToken = qs.get('event') || '';
  const t = qs.get('t') || '';

  const statusBox = document.getElementById('statusBox');
  const eventInfo = document.getElementById('eventInfo');
  const openBtn = document.getElementById('openBtn');
  const switchBtn = document.getElementById('switchBtn');
  const retryPermBtn = document.getElementById('retryPermBtn');
  const openInBrowserBtn = document.getElementById('openInBrowserBtn');
  const fileInput = document.getElementById('file');
  const camVid = document.getElementById('camVid');
  const videoWrap = document.getElementById('videoWrap');
  const previewImg = document.getElementById('previewImg');
  const captureBtn = document.getElementById('captureBtn');
  const hintBox = document.getElementById('hintBox');
  const inAppBox = document.getElementById('inAppBox');
  const flashEl = document.getElementById('flash');
  const toast = document.getElementById('toast');
  const fsBtn = document.getElementById('fsBtn');
  const progressOverlay = document.getElementById('progressOverlay');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const progressMessage = document.getElementById('progressMessage');
  const stopBtn = document.getElementById('stopBtn');
  const torchBtn = document.getElementById('torchBtn');
  const torchSvg = document.getElementById('torchSvg');

  function setOk(m){ statusBox.classList.remove('err'); statusBox.classList.add('ok'); statusBox.textContent = m; }
  function setErr(m){ statusBox.classList.remove('ok'); statusBox.classList.add('err'); statusBox.textContent = m; }

  if (!eventToken || !t) {
    eventInfo.textContent = 'Brak parametrów ?event= i ?t= w linku — działam w trybie testowym.';
    setOk('Tryb testowy — możesz przetestować aparat (brak param. event/t).');
  } else {
    eventInfo.textContent = `Wydarzenie: ${eventToken}`;
  }

  const memoryStore = {};
  const safeStorage = {
    get(k){
      try { return localStorage.getItem(k); } catch (ex) { return memoryStore[k] ?? null; }
    },
    set(k,v){
      try { localStorage.setItem(k,v); } catch (ex) { memoryStore[k] = String(v); }
    }
  };

  function makeUUID(){
    try {
      if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID();
      }
    } catch (e) {}
    try {
      if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
        const b = new Uint8Array(16);
        crypto.getRandomValues(b);
        b[6] = (b[6] & 0x0f) | 0x40;
        b[8] = (b[8] & 0x3f) | 0x80;
        const h = [...b].map(x => x.toString(16).padStart(2,'0')).join('');
        return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
      }
    } catch (e) {}
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,c=>{
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  const UUID_KEY = 'qrphoto_uuid';
  let uuid = safeStorage.get(UUID_KEY);
  if (!uuid) {
    uuid = makeUUID();
    safeStorage.set(UUID_KEY, uuid);
  }

  function detectInApp(){
    try {
      const ua = navigator.userAgent || navigator.vendor || '';
      const tests = ['FBAN','FBAV','Instagram','Line','Twitter','LinkedInApp','Vkontakte','Telegram','WhatsApp'];
      for (let i = 0; i < tests.length; i++) {
        if (ua.indexOf(tests[i]) !== -1) return tests[i];
      }
    } catch (e) {}
    return null;
  }

  const inApp = detectInApp();
  if (inApp) {
    inAppBox.style.display = 'block';
    inAppBox.innerHTML = `<strong>Wygląda na wbudowaną przeglądarkę (${inApp}).</strong> Jeśli aparat nie działa, kliknij "Otwórz w przeglądarce".`;
    openInBrowserBtn.style.display = 'inline-block';
  }

  window.addEventListener('error', (e) => { setErr('Błąd skryptu: ' + (e.message || 'nieznany')); });
  window.addEventListener('unhandledrejection', (e) => { setErr('Błąd obietnicy: ' + ((e && e.reason && e.reason.message) || 'nieznany')); });

  let activeStream = null;
  let uploading = false;
  let currentFacing = 'environment';
  let switching = false;
  let freezeTimer = null;
  let lastVideoTime = 0;
  let lastProgress = 0;
  let indeterminateTimer = null;
  let audioCtx = null;
  let torchSupported = false;
  let torchOn = false;

  function doFlash(){
    try {
      const target = document.fullscreenElement || videoWrap || document.body;
      if (target && flashEl.parentElement !== target) {
        target.appendChild(flashEl);
      }
      flashEl.classList.add('do');
      setTimeout(()=> flashEl.classList.remove('do'), 160);
    } catch (e) {}
  }

  function showToast(m){
    toast.textContent = m;
    toast.classList.add('show');
    setTimeout(()=> toast.classList.remove('show'), 2200);
  }

  async function checkPermissionState(){
    if (!navigator.permissions || !navigator.permissions.query) return null;
    try {
      const p = await navigator.permissions.query({ name: 'camera' });
      return p.state;
    } catch (e) {
      return null;
    }
  }

  function startFreezeWatcher(){
    lastVideoTime = camVid.currentTime || 0;
    if (freezeTimer) clearInterval(freezeTimer);
    freezeTimer = setInterval(()=>{
      const now = camVid.currentTime || 0;
      if (now === lastVideoTime) {
        if (typeof lastVideoTime === 'number') {
          lastVideoTime = { frozenSince: Date.now(), last: lastVideoTime };
        } else if (lastVideoTime && (Date.now() - lastVideoTime.frozenSince) > 1500) {
          handleCameraFreeze();
        }
      } else {
        lastVideoTime = now;
      }
    }, 500);
  }

  function stopFreezeWatcher(){
    if (freezeTimer) {
      clearInterval(freezeTimer);
      freezeTimer = null;
      lastVideoTime = 0;
    }
  }

  function handleCameraFreeze(){
    stopCamera();
    setErr('Podgląd aparatu uległ zacięciu — podgląd wyłączony. Użyj przycisku aby ponownie uruchomić aparat.');
    videoWrap.style.display = 'none';
    updateControlsVisibility();
  }

  async function getDeviceIdForFacing(facing){
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const vids = devices.filter(d => d.kind === 'videoinput');
      if (!vids.length) return null;
      const labelsAvailable = vids.every(d => !!d.label);
      if (labelsAvailable) {
        const needle = facing === 'user' ? ['front','user','face'] : ['back','rear','environment'];
        for (let i = 0; i < needle.length; i++) {
          const n = needle[i];
          const found = vids.find(v => v.label.toLowerCase().indexOf(n) !== -1);
          if (found) return found.deviceId;
        }
      }
      return facing === 'user' ? vids[0].deviceId : vids[vids.length - 1].deviceId;
    } catch (e) {
      return null;
    }
  }

  async function tryGetStream(facing){
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return null;
    try {
      return await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ exact:facing }, width:{ ideal:3840 }, height:{ ideal:2160 } }, audio:false });
    } catch (e1) {}
    try {
      return await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal:facing }, width:{ ideal:1920 }, height:{ ideal:1080 } }, audio:false });
    } catch (e2) {}
    const deviceId = await getDeviceIdForFacing(facing);
    if (deviceId) {
      try {
        return await navigator.mediaDevices.getUserMedia({ video:{ deviceId:{ exact:deviceId }, width:{ ideal:1920 }, height:{ ideal:1080 } }, audio:false });
      } catch (e3) {}
    }
    return null;
  }

  async function startCamera(){
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      setErr('getUserMedia niedostępny (webview lub stara przeglądarka).');
      fileInput.click();
      return;
    }
    setOk('Proszę o dostęp do aparatu...');
    try {
      stopCamera();
      const stream = await tryGetStream(currentFacing);
      if (!stream) {
        providePermissionHelp(new Error('Nie można uzyskać strumienia dla tego aparatu'));
        return;
      }
      activeStream = stream;
      camVid.srcObject = stream;
      camVid.playsInline = true;
      videoWrap.style.display = 'block';
      previewImg.style.display = 'none';
      try { await camVid.play(); } catch (e) {}
      setOk('Aparat uruchomiony — naciśnij środkowy przycisk, aby zrobić zdjęcie.');
      hintBox.textContent = 'Naciśnij środkowy przycisk, aby zrobić zdjęcie. Możesz przełączać aparaty i wejść w pełny ekran.';
      startFreezeWatcher();
      updateControlsVisibility();
      updateCapturePosition();
      try {
        const track = stream.getVideoTracks && stream.getVideoTracks()[0];
        const caps = track && track.getCapabilities ? track.getCapabilities() : null;
        torchSupported = !!(caps && caps.torch);
      } catch (e) { torchSupported = false; }
      torchBtn.classList.toggle('hidden', !torchSupported);
      if (!torchSupported) {
        torchOn = false;
        torchBtn.classList.remove('active');
      }
    } catch (err) {
      providePermissionHelp(err);
    }
  }

  function stopCamera(){
    stopFreezeWatcher();
    if (activeStream) {
      if (torchOn) {
        try {
          const track = activeStream.getVideoTracks && activeStream.getVideoTracks()[0];
          if (track && track.applyConstraints) track.applyConstraints({ advanced: [{ torch: false }] }).catch(()=>{});
        } catch (e) {}
        torchOn = false;
        torchBtn.classList.remove('active');
      }
      activeStream.getTracks().forEach(t => t.stop());
      activeStream = null;
    }
    try { camVid.srcObject = null; } catch (e) {}
    videoWrap.style.display = 'none';
    previewImg.style.display = 'none';
    updateControlsVisibility();
    torchBtn.classList.add('hidden');
  }

  function updateControlsVisibility(){
    const running = !!activeStream;
    openBtn.style.display = running ? 'none' : 'inline-block';
    retryPermBtn.style.display = running ? 'none' : 'inline-block';
    stopBtn.classList.toggle('hidden', !running);
  }

  function needRotateForDevice(origW, origH){
    const deviceLandscape = window.innerWidth > window.innerHeight;
    const videoLandscape = origW > origH;
    return deviceLandscape !== videoLandscape;
  }

  function rotateCanvas90(srcCanvas, clockwise){
    const sW = srcCanvas.width;
    const sH = srcCanvas.height;
    const dst = document.createElement('canvas');
    dst.width = sH;
    dst.height = sW;
    const ctx = dst.getContext('2d');
    if (clockwise) {
      ctx.translate(dst.width, 0);
      ctx.rotate(Math.PI/2);
      ctx.drawImage(srcCanvas, 0, 0);
    } else {
      ctx.translate(0, dst.height);
      ctx.rotate(-Math.PI/2);
      ctx.drawImage(srcCanvas, 0, 0);
    }
    return dst;
  }

  function setProgress(p){
    p = Math.max(0, Math.min(100, Math.round(p)));
    if (p < lastProgress) return;
    lastProgress = p;
    progressBar.style.width = p + '%';
    progressText.textContent = p + '%';
  }

  function animateTo100(){
    const start = lastProgress;
    const duration = Math.max(240, (100 - start) * 6);
    const startTime = performance.now();
    function step(now){
      const t = Math.min(1, (now - startTime) / duration);
      const val = Math.round(start + (100 - start) * t);
      setProgress(val);
      if (t < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function startIndeterminateProgress(){
    stopIndeterminateProgress();
    progressOverlay.classList.add('visible');
    let pct = Math.max(6, lastProgress || 8);
    setProgress(pct);
    indeterminateTimer = setInterval(()=>{
      pct = pct + (Math.random() * 4 + 1.5);
      if (pct > 88) pct = 60 + Math.random() * 12;
      setProgress(Math.min(90, Math.round(pct)));
    }, 240);
  }

  function stopIndeterminateProgress(){
    if (indeterminateTimer) {
      clearInterval(indeterminateTimer);
      indeterminateTimer = null;
    }
  }

  function playShutter(){
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
      const now = audioCtx.currentTime;
      const master = audioCtx.createGain();
      master.gain.value = 0.7;
      master.connect(audioCtx.destination);

      const click = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * 0.02), audioCtx.sampleRate);
      const d = click.getChannelData(0);
      for (let i = 0; i < d.length; i++) d[i] = (Math.random()*2 - 1) * Math.pow(1 - i/d.length, 2) * 0.6;
      const src = audioCtx.createBufferSource();
      src.buffer = click;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(1, now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
      src.connect(g);
      g.connect(master);
      src.start(now);
      src.stop(now + 0.08);

      const osc = audioCtx.createOscillator();
      const og = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(900, now + 0.02);
      og.gain.setValueAtTime(0.0001, now + 0.02);
      og.gain.exponentialRampToValueAtTime(0.28, now + 0.025);
      og.gain.exponentialRampToValueAtTime(0.0001, now + 0.09);
      osc.connect(og);
      og.connect(master);
      osc.start(now + 0.02);
      osc.stop(now + 0.09);
    } catch (e) {}
  }

  async function captureBlobViaImageCapture(){
    try {
      const track = activeStream && activeStream.getVideoTracks && activeStream.getVideoTracks()[0];
      if (!track || typeof ImageCapture === 'undefined') throw new Error('no-imagecapture');
      const ic = new ImageCapture(track);
      if (!ic.takePhoto) throw new Error('no-takephoto');
      const blob = await ic.takePhoto();
      return blob;
    } catch (e) {
      throw e;
    }
  }

  async function captureAndUpload(){
    if (uploading) return;
    if (!camVid || camVid.readyState < 2) { setErr('Aparat niegotowy.'); return; }

    lastProgress = 0;
    setProgress(0);

    uploading = true;
    captureBtn.disabled = true;
    let blob = null;
    try {
      try {
        blob = await captureBlobViaImageCapture();
      } catch (e) {
        blob = null;
      }
      if (!blob) {
        const rawW = camVid.videoWidth || 1280;
        const rawH = camVid.videoHeight || 720;
        const tmp = document.createElement('canvas');
        tmp.width = rawW;
        tmp.height = rawH;
        const tctx = tmp.getContext('2d');
        tctx.drawImage(camVid, 0, 0, rawW, rawH);
        let finalCanvas = tmp;
        if (needRotateForDevice(rawW, rawH)) finalCanvas = rotateCanvas90(tmp, true);
        blob = await new Promise(res => finalCanvas.toBlob(res, 'image/jpeg', 0.98));
      }
      if (!blob) {
        setErr('Nie udało się przygotować zdjęcia');
        uploading = false;
        captureBtn.disabled = false;
        return;
      }

      doFlash();
      playShutter();

      const url = URL.createObjectURL(blob);
      previewImg.src = url;
      previewImg.style.display = 'block';
      camVid.style.display = 'none';
      progressOverlay.classList.add('visible');

      try {
        await uploadFileWithProgress(new File([blob], 'photo.jpg', { type: blob.type }));
        setOk('Wysłano ✅');
        progressMessage.textContent = 'Wysłano';
        showToast('Wysłano');
        animateTo100();
        setTimeout(()=>{ progressOverlay.classList.remove('visible'); progressMessage.textContent = ''; lastProgress = 0; }, 1100);
        setTimeout(()=>{ if (previewImg.src) URL.revokeObjectURL(previewImg.src); previewImg.style.display = 'none'; camVid.style.display = 'block'; }, 900);
      } catch (e) {
        progressMessage.textContent = 'Błąd wysyłania';
        setErr('Błąd wysyłania');
        setTimeout(()=>{ progressOverlay.classList.remove('visible'); progressMessage.textContent = ''; lastProgress = 0; }, 2000);
        setTimeout(()=>{ if (previewImg.src) URL.revokeObjectURL(previewImg.src); previewImg.style.display = 'none'; camVid.style.display = 'block'; }, 900);
      }
    } finally {
      uploading = false;
      captureBtn.disabled = false;
      progressBar.style.width = '0%';
      progressText.textContent = '…';
      stopIndeterminateProgress();
      lastProgress = 0;
    }
  }

  function uploadFileWithProgress(file){
    progressMessage.textContent = '';
    startIndeterminateProgress();
    return new Promise((res, rej) => {
      const fd = new FormData();
      fd.append('file', file, file.name || 'photo.jpg');
      fd.append('event', eventToken);
      fd.append('uuid', uuid);
      fd.append('t', t);

      const xhr = new XMLHttpRequest();
      xhr.open('POST', WORKER_URL, true);
      xhr.timeout = 60000;
      let seenReal = false;

      xhr.upload.onprogress = (e) => {
        if (e.lengthComputable) {
          if (!seenReal) { seenReal = true; stopIndeterminateProgress(); }
          const pct = Math.round((e.loaded / e.total) * 100);
          setProgress(pct);
        } else {
          if (!indeterminateTimer) startIndeterminateProgress();
        }
      };

      xhr.onload = () => {
        stopIndeterminateProgress();
        let json = {};
        try { json = JSON.parse(xhr.responseText || '{}'); } catch (err) { json = {}; }
        if (xhr.status >= 200 && xhr.status < 300) {
          animateTo100();
          progressMessage.textContent = 'Sukces';
          setTimeout(()=>{ progressMessage.textContent = 'Wysłano'; }, 300);
          setTimeout(()=>{ lastProgress = 100; res(json); }, 650);
        } else {
          progressMessage.textContent = 'Błąd';
          lastProgress = 0;
          rej(json);
        }
      };

      xhr.onerror = () => { stopIndeterminateProgress(); progressMessage.textContent = 'Błąd sieci'; lastProgress = 0; rej(new Error('network')); };
      xhr.ontimeout = () => { stopIndeterminateProgress(); progressMessage.textContent = 'Timeout'; lastProgress = 0; rej(new Error('timeout')); };

      try {
        xhr.send(fd);
      } catch (e) {
        stopIndeterminateProgress();
        progressMessage.textContent = 'Błąd wysyłania';
        lastProgress = 0;
        rej(e);
      }
    });
  }

  fileInput.addEventListener('change', async () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) { setErr('Brak pliku'); return; }
    lastProgress = 0;
    setProgress(0);
    setOk('Wybrano plik — wysyłam...');
    try {
      await uploadFileWithProgress(f);
      setOk('Wysłano ✅');
      showToast('Wysłano');
      setTimeout(()=>{ progressOverlay.classList.remove('visible'); progressMessage.textContent = ''; lastProgress = 0; }, 1200);
    } catch (e) {
      setErr('Błąd uploadu');
      setTimeout(()=>{ progressOverlay.classList.remove('visible'); progressMessage.textContent = ''; lastProgress = 0; }, 1600);
    } finally {
      progressBar.style.width = '0%';
      progressText.textContent = '…';
      stopIndeterminateProgress();
      lastProgress = 0;
    }
  });

  openBtn.addEventListener('click', async () => { await startCamera(); });
  captureBtn.addEventListener('click', captureAndUpload);
  stopBtn.addEventListener('click', () => { stopCamera(); });

  switchBtn.addEventListener('click', async () => {
    if (switching) return;
    switching = true;
    try {
      currentFacing = currentFacing === 'environment' ? 'user' : 'environment';
      await startCamera();
    } finally {
      switching = false;
    }
  });

  retryPermBtn.addEventListener('click', async () => {
    setOk('Sprawdzam stan uprawnień...');
    const state = await checkPermissionState();
    if (state === 'granted') { setOk('Uprawnienia przyznane — uruchamiam aparat...'); await startCamera(); return; }
    if (state === 'prompt' || state === null) { setOk('Spróbuję ponownie poprosić o dostęp...'); await startCamera(); return; }
    if (state === 'denied') { setErr('Uprawnienie zablokowane. Zobacz instrukcje w polu poniżej.'); showPermissionInstructions(); return; }
    setErr('Nie można sprawdzić uprawnień — spróbuj ręcznie w ustawieniach lub otwórz w innej przeglądarce.');
  });

  function providePermissionHelp(err){
    const msg = err && err.name ? err.name : String(err);
    setErr('Dostęp do aparatu odrzucony lub zablokowany: ' + msg + '\nZobacz instrukcje poniżej.');
    showPermissionInstructions();
  }

  function showPermissionInstructions(){
    inAppBox.style.display = 'block';
    inAppBox.innerHTML = `<strong>Jak odblokować aparat?</strong>
      <ol>
        <li>Jeśli jesteś w aplikacji (Facebook/Instagram) — wybierz "Otwórz w przeglądarce" i spróbuj ponownie.</li>
        <li>iOS: Ustawienia → Safari (lub inna przeglądarka) → Aparat → Zezwól.</li>
        <li>Android: Ustawienia → Aplikacje → Chrome (lub inna) → Uprawnienia → Aparat → Zezwól.</li>
        <li>Możesz też usunąć blokadę dla tej strony w ustawieniach witryny (Site settings → Camera / Aparat).</li>
      </ol>
      Po zmianie ustawień wróć tutaj i naciśnij "Sprawdź uprawnienia".`;
  }

  openInBrowserBtn.addEventListener('click', ()=>{ window.open(location.href, '_blank', 'noopener'); });

  window.addEventListener('pagehide', ()=>{ if (activeStream) activeStream.getTracks().forEach(t=>t.stop()); });

  fsBtn.addEventListener('click', async ()=>{
    try {
      if (!document.fullscreenElement) await videoWrap.requestFullscreen();
      else await document.exitFullscreen();
    } catch (e) {}
  });

  document.addEventListener('fullscreenchange', ()=> {
    try {
      if (document.fullscreenElement) {
        if (flashEl.parentElement !== document.fullscreenElement) document.fullscreenElement.appendChild(flashEl);
      } else {
        if (flashEl.parentElement !== document.body) document.body.appendChild(flashEl);
      }
    } catch (e) {}
  });

  function getOrientationAngle(){
    try {
      if (screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;
      if (typeof window.orientation === 'number') return (window.orientation + 360) % 360;
    } catch (e) {}
    return 0;
  }

  function updateCapturePosition(){
    const angle = getOrientationAngle();
    captureBtn.classList.remove('bottomCenter','topCenter','leftCenter','rightCenter');
    if (angle === 0) captureBtn.classList.add('bottomCenter');
    else if (angle === 180) captureBtn.classList.add('topCenter');
    else if (angle === 90) captureBtn.classList.add('rightCenter');
    else if (angle === 270) captureBtn.classList.add('leftCenter');
    else captureBtn.classList.add(window.innerWidth > window.innerHeight ? 'rightCenter' : 'bottomCenter');
  }

  try {
    if (screen.orientation && screen.orientation.addEventListener) {
      screen.orientation.addEventListener('change', ()=>{ updateCapturePosition(); });
    }
  } catch (e) {}

  window.addEventListener('orientationchange', ()=>{ setTimeout(()=> updateCapturePosition(), 120); });

  function updateTorchButtonState(){
    torchBtn.classList.toggle('hidden', !torchSupported);
    if (torchOn) torchBtn.classList.add('active'); else torchBtn.classList.remove('active');
    torchBtn.title = torchOn ? 'Lampa: włączona' : 'Lampa: wyłączona';
  }

  async function setTorch(on){
    if (!activeStream) return;
    try {
      const track = activeStream.getVideoTracks && activeStream.getVideoTracks()[0];
      if (!track || !track.applyConstraints) throw new Error('no-track');
      await track.applyConstraints({ advanced: [{ torch: !!on }] });
      torchOn = !!on;
      updateTorchButtonState();
    } catch (e) {
      torchSupported = false;
      torchOn = false;
      updateTorchButtonState();
      showToast('Lampa nieobsługiwana na tym urządzeniu');
    }
  }

  torchBtn.addEventListener('click', async ()=>{
    if (!torchSupported) { showToast('Lampa nieobsługiwana'); return; }
    await setTorch(!torchOn);
  });

  updateControlsVisibility();
  updateCapturePosition();
  updateTorchButtonState();

})();
</script>
</body>
</html>







